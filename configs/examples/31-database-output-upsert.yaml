# Example: Database Upsert (Insert or Update)
# Demonstrates upsert operations using native SQL syntax

schemaVersion: "1.1.0"

connector:
  name: database-upsert-example
  version: "1.0.0"
  description: "Sync products with upsert (insert or update on conflict)"

  input:
    type: httpPolling
    endpoint: "https://api.source.com/products"
    method: GET
    schedule: "*/15 * * * *"

  filters:
    - type: mapping
      mappings:
        - source: "sku"
          target: "sku"
        - source: "name"
          target: "product_name"
        - source: "price"
          target: "price"
        - source: "stock"
          target: "stock_quantity"

  output:
    type: database
    connectionStringRef: "${DATABASE_URL}"

    # PostgreSQL upsert: ON CONFLICT DO UPDATE
    query: |
      INSERT INTO products (sku, name, price, stock, last_sync)
      VALUES ({{record.sku}}, {{record.product_name}}, {{record.price}}, {{record.stock_quantity}}, NOW())
      ON CONFLICT (sku) DO UPDATE SET
        name = EXCLUDED.name,
        price = EXCLUDED.price,
        stock = EXCLUDED.stock,
        last_sync = EXCLUDED.last_sync

    # For MySQL, use ON DUPLICATE KEY UPDATE:
    # query: |
    #   INSERT INTO products (sku, name, price, stock, last_sync)
    #   VALUES ({{record.sku}}, {{record.product_name}}, {{record.price}}, {{record.stock_quantity}}, NOW())
    #   ON DUPLICATE KEY UPDATE
    #     name = VALUES(name),
    #     price = VALUES(price),
    #     stock = VALUES(stock),
    #     last_sync = VALUES(last_sync)

    # For SQLite, use INSERT OR REPLACE:
    # query: |
    #   INSERT OR REPLACE INTO products (sku, name, price, stock, last_sync)
    #   VALUES ({{record.sku}}, {{record.product_name}}, {{record.price}}, {{record.stock_quantity}}, datetime('now'))

    transaction: true
    onError: fail
